<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spritesheet inspector</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 1rem; }
    .sheet { position: relative; display: inline-block; image-rendering: pixelated; }
    .sheet img { display:block; image-rendering: pixelated; }
    .overlay { position:absolute; left:0; top:0; cursor:crosshair; pointer-events:auto; }
    .cell { position:absolute; border:1px solid rgba(255,255,255,0.08); box-sizing:border-box; font-size:9px; color:yellow; text-shadow: 0 0 2px black; }
    .controls { margin-left: 1rem; max-width: 520px; }
    .controls .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .controls select, .controls button, .controls input { padding:6px 8px; font-size:13px; }
    .controls .assign-btn { background: #28a745; color: #fff; border-radius:4px; border: none; cursor: pointer; }
    .controls .small { font-size:12px; padding:4px 6px; }
    pre.snippet { background:#0b1220; color:#9fe8c9; padding:8px; border-radius:6px; max-height:200px; overflow:auto; font-size:12px; }
    table { margin-left:1rem; border-collapse: collapse; }
    td,th { border:1px solid #ddd; padding:6px 8px; }
    .group { display:inline-block; padding:2px 6px; margin:2px; border-radius:4px; background:rgba(0,0,0,0.6); color:#fff; cursor:pointer; }
    .highlight { outline:3px solid rgba(0,200,100,0.65); }
  </style>
</head>
<body>
  <h2>Spritesheet inspector — bomberman_sheet_V2.png</h2>
  <div style="display:flex;align-items:flex-start">
    <div class="sheet">
      <img id="sheetImg" src="../assets/bomberman_sheet_V2.png" alt="sheet">
      <canvas id="overlay" class="overlay"></canvas>
    </div>
    <div class="controls">
      <h3>Detected frames (48×48)</h3>
      <p>Columns: <strong id="colsCount">28</strong> × Rows: <strong id="rowsCount">5</strong> — total frames: <strong id="framesCount">140</strong></p>

      <div class="row">
        <label>Spritesheet:</label>
        <select id="sheetSelect">
          <option value="bomberman_sheet_V2.png">bomberman_sheet_V2.png</option>
        </select>
        <button id="reloadSheet" class="small">Reload</button>
      </div>

      <div class="row">
        <label style="min-width:84px">Grid cell</label>
        <input id="cellW" type="number" min="1" value="48" style="width:80px"> x
        <input id="cellH" type="number" min="1" value="48" style="width:80px"> px
        <label style="min-width:60px; margin-left:12px">Cols</label>
        <input id="colsInput" type="number" min="1" value="18" style="width:72px">
        <label style="min-width:40px; margin-left:8px">Rows</label>
        <input id="rowsInput" type="number" min="1" value="5" style="width:72px">
      </div>

      <div class="row">
        <label style="min-width:84px">Grid offset</label>
        <div style="display:inline-flex; gap:6px; align-items:center">
          <button id="gridOffsetXdec" class="small">-1</button>
          <input id="gridOffsetX" type="number" value="0" style="width:80px">
          <button id="gridOffsetXinc" class="small">+1</button>
          <span style="opacity:0.7; padding-right:6px">x</span>
          <button id="gridOffsetYdec" class="small">-1</button>
          <input id="gridOffsetY" type="number" value="0" style="width:80px">
          <button id="gridOffsetYinc" class="small">+1</button>
          <span style="opacity:0.7; padding-left:6px">px</span>
        </div>
        <button id="applyGrid" class="small">Apply grid</button>
        <button id="resetGrid" class="small">Reset detected</button>
      </div>

      <div class="row">
        <label style="min-width:84px">Zoom</label>
        <button id="zoomDec" class="small">-</button>
        <input id="zoomInput" type="number" min="0.1" step="0.01" value="1" style="width:80px"> x
        <button id="zoomInc" class="small">+</button>
        <button id="zoomOne" class="small">1:1</button>
        <button id="zoom2x" class="small">2x</button>
      </div>

      <div class="row">
        <label>Selected frames:</label>
        <div id="selectedList">(none)</div>
      </div>

      <div class="row">
        <select id="animSelect">
          <option value="idle">idle</option>
          <option value="walk">walk</option>
          <option value="liftIdle">lift idle</option>
          <option value="liftWalk">lift walk</option>
          <option value="throw">throw</option>
          <option value="punch">punch</option>
          <option value="push">push</option>
          <option value="jumpWarp">jump/warp</option>
          <option value="stun">stun</option>
          <option value="bomberCart">bomber cart</option>
          <option value="waiting">waiting</option>
          <option value="victory">victory</option>
          <option value="drawGame">draw game</option>
          <option value="minecart">minecart</option>
          <option value="specialExploder">special exploder</option>
          <option value="explode">explode</option>
        </select>

        <select id="directionSelect" style="display:none;">
          <option value="down">down</option>
          <option value="left">left</option>
          <option value="right">right</option>
          <option value="up">up</option>
          <option value="upleft">upleft</option>
          <option value="upright">upright</option>
          <option value="downleft">downleft</option>
          <option value="downright">downright</option>
        </select>

        <button id="assignBtn" class="assign-btn">Assign</button>
        <button id="clearSel" class="small">Clear selection</button>
      </div>

      <div class="row">
        <label style="min-width:84px">Custom anim</label>
        <input id="newAnimName" type="text" placeholder="name (letters, numbers, _-)" style="width:160px">
        <label style="display:inline-flex;align-items:center;gap:6px"><input id="newAnimDirectional" type="checkbox"> directional</label>
        <button id="addAnimBtn" class="small">Add</button>
        <button id="removeAnimBtn" class="small" title="Remove selected custom animation" disabled>Remove</button>
      </div>

      <div style="margin-top:8px; display:flex; gap:8px; align-items:center">
        <button id="cropModeToggle" class="small">Crop mode</button>
        <button id="autoFitSelected" class="small">Auto-fit selected</button>
        <button id="autoFitAll" class="small">Auto-fit all</button>
        <button id="clearCrops" class="small">Clear crops</button>
      </div>

      <div style="margin-top:8px; display:flex; gap:16px; align-items:flex-start">
        <div style="width:260px;">
          <label style="font-weight:600; display:block; margin-bottom:6px">Selection preview (pixel-zoom)</label>
          <canvas id="cellPreview" width="192" height="192" style="background:#0b1220; display:block; border:1px solid #ddd; image-rendering: pixelated; width:192px; height:192px"></canvas>
          <div style="margin-top:6px; display:flex; gap:6px; align-items:center; flex-wrap:wrap">
            <label style="font-size:12px">Zoom</label>
            <input id="previewZoom" type="number" min="1" step="1" value="4" style="width:56px">
            <button id="previewZoomDec" class="small">-</button>
            <button id="previewZoomInc" class="small">+</button>
            <button id="previewZoomFit" class="small">Fit</button>
          </div>
          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
            <button id="nudgeLeft" class="small">◀ -1</button>
            <button id="nudgeRight" class="small">+1 ▶</button>
            <button id="nudgeUp" class="small">▲ -1</button>
            <button id="nudgeDown" class="small">+1 ▼</button>
            <button id="trimBlue" class="small">Trim blue border</button>
            <button id="applyPreviewToSelected" class="small">Apply to selected</button>
          </div>

          <div style="margin-top:8px; display:flex; gap:6px; align-items:center;">
            <label style="font-size:12px;">Uniform trim (px)</label>
            <input id="uniformTrimInput" type="number" min="0" step="1" value="1" style="width:64px">
            <button id="trimUniformSelected" class="small">Trim selected</button>
            <button id="trimUniformAll" class="small">Trim all</button>
            <button id="resetUniformTrim" class="small">Reset</button>
          </div>

          <div style="margin-top:8px; font-size:12px; color:#444">
            <div>FrameBox (source px): <code id="previewFB">(none)</code></div>
            <div style="margin-top:6px;">Tip: use the nudge buttons or drag-crop, then <b>Apply</b> to set for all selected frames. Use <b>Trim all</b> to crop N px from every side across the sheet.</div>
          </div>
        </div>

        <div style="flex:1">
          <strong>Assigned mappings</strong>
          <table style="width:100%; margin-top:6px; border-collapse:collapse;">
            <thead><tr><th style="width:40%">animation</th><th style="width:40%">definition</th><th style="width:20%">actions</th></tr></thead>
            <tbody id="assignedTable"></tbody>
          </table>
          <div id="cropsSummary" style="margin-top:6px; color:#555">Crops: 0</div>
        </div>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px; align-items:center">
        <button id="autoFill" class="small">Auto-fill walk/idle</button>
        <button id="downloadJson" class="small">Download JSON</button>
        <button id="copyJson" class="small">Copy JSON</button>
        <button id="importJsonBtn" class="small">Import JSON</button>
        <input id="importJsonFile" type="file" accept=".json" style="display:none">
        <button id="pasteJsonBtn" class="small">Paste JSON</button>
        <button id="exportSnippet" class="small">Show assets.js snippet</button>
      </div>

      <div style="margin-top:10px;">
        <label style="font-weight:600">Export preview (animations + frameBoxes)</label>
        <pre id="exportPreview" class="snippet">(no mappings)</pre>
      </div>
    </div>
  </div>

  <script>
    let fw = 48, fh = 48; let cols = 28, rows = 5;
    let gridOffsetX = 0, gridOffsetY = 0; // source-pixel offsets (detected from markers)
    let detectedGridOffsetX = 0, detectedGridOffsetY = 0; // last-detected values
    let gridLocked = false; // when true, manual grid/offset won't be overridden by auto-detection

    function getDisplayCellSize(){
      // map source pixels (fw,fh) to CSS display pixels using image scale
      const rect = img.getBoundingClientRect();
      const scaleX = rect.width / img.naturalWidth;
      const scaleY = rect.height / img.naturalHeight;
      // use X/Y scale separately so non-square scaling (if any) is handled consistently
      return { cw: fw * scaleX, ch: fh * scaleY, scaleX, scaleY };
    }
    function getDisplayGridOffset(){
      const rect = img.getBoundingClientRect();
      const { scaleX, scaleY } = getDisplayCellSize();
      return { ox: gridOffsetX * scaleX, oy: gridOffsetY * scaleY };
    }

    // return a stable, rounded display rectangle for a cell (prevents sub-pixel drift)
    function displayCellRect(r, c){
      const { cw, ch } = getDisplayCellSize();
      const { ox, oy } = getDisplayGridOffset();
      // round to 2 decimal places so every draw call uses the same coordinates
      const x = Math.round((ox + c * cw) * 100) / 100;
      const y = Math.round((oy + r * ch) * 100) / 100;
      const w = Math.round(cw * 100) / 100;
      const h = Math.round(ch * 100) / 100;
      return { x, y, w, h };
    }

    const img = document.getElementById('sheetImg');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    // inspector state
    const selected = new Set(); // indices
    const mappingData = {}; // animations mapping
    const frameBoxes = {}; // per-frame user/autofit crops: index -> {x,y,w,h} (source pixels)
    let cellMeta = new Array(cols * rows).fill(null); // auto-detected bbox per cell
    let cropMode = false;
    let cropDrag = null; // { startCell, startPt, curPt }

    function indexToRC(idx){ return { r: Math.floor(idx/cols), c: idx % cols }; }
    function rcToIndex(r,c){ return r*cols + c; }

    function drawIndices(){
      // clear using CSS pixels (context is scaled to CSS px via setTransform)
      ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
      const { cw, ch } = getDisplayCellSize();
      const { ox, oy } = getDisplayGridOffset();
      // grid
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
      ctx.fillStyle = 'rgba(255,255,0,0.9)'; ctx.font = '9px monospace';
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const base = displayCellRect(r, c);
          ctx.strokeRect(base.x + 0.5, base.y + 0.5, base.w - 1, base.h - 1);
          ctx.fillText(r*cols + c, base.x + 3, base.y + 11);
        }
      }
    }

    function drawSelected(){
      const { cw, ch } = getDisplayCellSize();
      const { ox, oy } = getDisplayGridOffset();
      selected.forEach(idx => {
        const {r,c} = indexToRC(idx);
        const base = displayCellRect(r,c);
        ctx.fillStyle = 'rgba(30,144,255,0.25)'; ctx.fillRect(base.x+1, base.y+1, base.w-2, base.h-2);
        ctx.strokeStyle = 'rgba(30,144,255,0.9)'; ctx.lineWidth = 2; ctx.strokeRect(base.x+1.5, base.y+1.5, base.w-3, base.h-3);
      });
    }

    function drawAssigned(){
      const { cw, ch } = getDisplayCellSize();
      const { ox, oy } = getDisplayGridOffset();
      // draw animations (green)
      function drawForDef(def){
        if (!def) return;
        if (Array.isArray(def)){
          def.forEach(idx => { const {r,c} = indexToRC(idx); const base = displayCellRect(r,c); ctx.strokeStyle = 'rgba(0,200,100,0.85)'; ctx.lineWidth = 2; ctx.strokeRect(base.x+2, base.y+2, base.w-4, base.h-4); });
        } else if (typeof def === 'object' && def.row != null && def.start != null && def.count != null){
          const r = def.row, start = def.start, count = def.count;
          for (let i=0;i<count;i++){ const c = start + i; const base = displayCellRect(r,c); ctx.strokeStyle = 'rgba(0,200,100,0.85)'; ctx.lineWidth = 2; ctx.strokeRect(base.x+2, base.y+2, base.w-4, base.h-4); }
        }
      }
      Object.entries(mappingData).forEach(([k,v]) => {
        if (k === 'walk' && typeof v === 'object') Object.values(v).forEach(drawForDef);
        else drawForDef(v);
      });

      // draw auto-detected cell bbox (dashed, subtle)
      ctx.setLineDash([3,3]);
      for (let idx=0; idx<cellMeta.length; idx++){
        const meta = cellMeta[idx];
        if (!meta || meta.empty) continue;
        const {r,c} = indexToRC(idx);
        const box = meta.bbox; // source px
        const base = displayCellRect(r,c);
        const x = base.x + (box.x / fw) * base.w;
        const y = base.y + (box.y / fh) * base.h;
        const w = (box.w / fw) * base.w;
        const h = (box.h / fh) * base.h;
        ctx.strokeStyle = 'rgba(100,140,220,0.25)'; ctx.lineWidth = 1; ctx.strokeRect(x+1, y+1, w-2, h-2);
      }
      ctx.setLineDash([]);

      // draw user/autofit frameBoxes (orange)
      Object.entries(frameBoxes).forEach(([k,v]) => {
        const idx = Number(k); const {r,c} = indexToRC(idx);
        const base = displayCellRect(r,c);
        const x = base.x + (v.x / fw) * base.w;
        const y = base.y + (v.y / fh) * base.h;
        const w = (v.w / fw) * base.w;
        const h = (v.h / fh) * base.h;
        ctx.fillStyle = 'rgba(255,140,0,0.12)'; ctx.fillRect(x+1, y+1, w-2, h-2);
        ctx.strokeStyle = 'rgba(255,140,0,0.95)'; ctx.lineWidth = 2; ctx.strokeRect(x+1, y+1, w-2, h-2);
      });

      // draw active crop-drag rectangle if any
      if (cropDrag && cropDrag.rect){
        const rect = cropDrag.rect;
        ctx.strokeStyle = 'rgba(255,99,71,0.95)'; ctx.lineWidth = 2; ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      }
    }

    function redraw(){ drawIndices(); drawAssigned(); drawSelected(); updateSelectedList(); renderAssignedTable(); updateExportPreview(); updateCropsSummary(); }

    // convert page coords -> cell/idx
    function canvasCoordsToCell(x,y){
      const rect = canvas.getBoundingClientRect();
      const cx = x - rect.left, cy = y - rect.top;
      // use display cell size (CSS pixels) and account for detected grid offset
      const { cw, ch } = getDisplayCellSize();
      const { ox, oy } = getDisplayGridOffset();
      const col = Math.floor((cx - ox + 1e-6) / cw);
      const row = Math.floor((cy - oy + 1e-6) / ch);
      if (row < 0 || row >= rows || col < 0 || col >= cols) return null;
      return { row, col, idx: rcToIndex(row,col), localX: cx - ox - col*cw, localY: cy - oy - row*ch };
    }

    // -- sheet pixel analysis (auto-detect bbox per cell) --
    let sheetCanvas = null; let sheetCtx = null;

    // detect global grid offset by scanning blue marker pixels
    function detectGridOffsetFromMarkers(ctx){
      try{
        const w = img.naturalWidth, h = img.naturalHeight;
        const data = ctx.getImageData(0,0,w,h).data;
        const xs = [];
        const ys = [];
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            const i = (y*w + x)*4;
            const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
            if (a > 32 && b > 120 && (b - Math.max(r,g) > 40)){
              xs.push(x); ys.push(y);
            }
          }
        }
        if (xs.length === 0) { detectedGridOffsetX = 0; detectedGridOffsetY = 0; if (!gridLocked){ gridOffsetX = 0; gridOffsetY = 0; } return; }
        // compute mode of remainders mod fw/fh
        const remX = new Array(fw).fill(0);
        const remY = new Array(fh).fill(0);
        xs.forEach(x => remX[x % fw]++);
        ys.forEach(y => remY[y % fh]++);
        const bestRx = remX.indexOf(Math.max(...remX));
        const bestRy = remY.indexOf(Math.max(...remY));
        // store detected offsets
        detectedGridOffsetX = bestRx; detectedGridOffsetY = bestRy;
        // only override active grid if not locked by the user
        if (!gridLocked){
          gridOffsetX = detectedGridOffsetX;
          gridOffsetY = detectedGridOffsetY;
          cols = Math.floor((img.naturalWidth - gridOffsetX) / fw);
          rows = Math.floor((img.naturalHeight - gridOffsetY) / fh);
        }
      } catch(e){ console.warn('detectGridOffsetFromMarkers failed', e); detectedGridOffsetX = 0; detectedGridOffsetY = 0; if (!gridLocked){ gridOffsetX = 0; gridOffsetY = 0; } }
    }

    function computeCellMeta(){
      // create offscreen at natural size (source pixels)
      sheetCanvas = document.createElement('canvas');
      sheetCanvas.width = img.naturalWidth; sheetCanvas.height = img.naturalHeight;
      sheetCtx = sheetCanvas.getContext('2d');
      sheetCtx.drawImage(img, 0, 0, sheetCanvas.width, sheetCanvas.height);

      // detect global grid offset from blue markers first (so grid aligns to image)
      detectGridOffsetFromMarkers(sheetCtx);

      cellMeta = new Array(cols * rows).fill(null);

      // helper to detect blue marker pixels inside a cell
      function isBlue(r,g,b,a){
        if (a < 32) return false;
        return (b > 120) && (b - Math.max(r,g) > 40);
      }

      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const sx = gridOffsetX + c * fw, sy = gridOffsetY + r * fh;
          try{
            const data = sheetCtx.getImageData(sx, sy, fw, fh).data;
            let minX = fw, minY = fh, maxX = -1, maxY = -1;
            let minBX = fw, minBY = fh, maxBX = -1, maxBY = -1; // blue marker bbox
            for (let yy=0; yy<fh; yy++){
              for (let xx=0; xx<fw; xx++){
                const i = (yy*fw + xx)*4;
                const rr = data[i], gg = data[i+1], bb = data[i+2], aa = data[i+3];
                // non-transparent content bounds
                if (aa > 16){ if (xx < minX) minX = xx; if (yy < minY) minY = yy; if (xx > maxX) maxX = xx; if (yy > maxY) maxY = yy; }
                // marker detection
                if (isBlue(rr,gg,bb,aa)){
                  if (xx < minBX) minBX = xx; if (yy < minBY) minBY = yy; if (xx > maxBX) maxBX = xx; if (yy > maxBY) maxBY = yy;
                }
              }
            }
            const idx = r*cols + c;
            if (maxX === -1){
              if (maxBX !== -1){
                cellMeta[idx] = { empty: true, marker: true, markerBBox: { x: minBX, y: minBY, w: maxBX-minBX+1, h: maxBY-minBY+1 } };
              } else {
                cellMeta[idx] = { empty: true };
              }
            } else {
              const bbox = { x: minX, y: minY, w: (maxX-minX+1), h: (maxY-minY+1) };
              const out = { empty: false, bbox };
              if (maxBX !== -1) out.markerBBox = { x: minBX, y: minBY, w: maxBX-minBX+1, h: maxBY-minBY+1 };
              cellMeta[idx] = out;
            }
          } catch(e){ cellMeta[r*cols + c] = { empty: true }; }
        }
      }
    }

    // mouse handling (selection OR crop mode)
    canvas.addEventListener('mousedown', (ev) => {
      const cell = canvasCoordsToCell(ev.clientX, ev.clientY);
      if (!cell) return;
      if (cropMode){
        cropDrag = { startCell: { r: cell.row, c: cell.col }, startPt: { x: ev.clientX, y: ev.clientY }, rect: null };
        return;
      }
      // normal selection
      let dragging = true; // local
      dragStart = cell; lastSelected = cell.idx;
      if (!ev.shiftKey && !ev.ctrlKey) selected.clear();
      selected.add(cell.idx);
      redraw();
      window.addEventListener('mousemove', selDragMove);
      window.addEventListener('mouseup', function selDragUp(){ window.removeEventListener('mousemove', selDragMove); window.removeEventListener('mouseup', selDragUp); dragStart = null; });

      function selDragMove(ev2){
        const cell2 = canvasCoordsToCell(ev2.clientX, ev2.clientY); if (!cell2) return;
        const r0 = Math.min(dragStart.row, cell2.row), r1 = Math.max(dragStart.row, cell2.row);
        const c0 = Math.min(dragStart.col, cell2.col), c1 = Math.max(dragStart.col, cell2.col);
        selected.clear();
        for (let r=r0;r<=r1;r++) for (let c=c0;c<=c1;c++) selected.add(rcToIndex(r,c));
        redraw();
      }
    });

    window.addEventListener('mousemove', (ev)=>{
      if (!cropDrag) return;
      const rectBounds = canvas.getBoundingClientRect();
      const { cw, ch } = getDisplayCellSize();
      const cellW = cw, cellH = ch;
      const sx = Math.min(ev.clientX, cropDrag.startPt.x);
      const sy = Math.min(ev.clientY, cropDrag.startPt.y);
      const ex = Math.max(ev.clientX, cropDrag.startPt.x);
      const ey = Math.max(ev.clientY, cropDrag.startPt.y);
      // restrict to the same start cell area (use display grid offset)
      const { ox, oy } = getDisplayGridOffset();
      const baseX = cropDrag.startCell.c * cellW + (canvas.getBoundingClientRect().left + ox);
      const baseY = cropDrag.startCell.r * cellH + (canvas.getBoundingClientRect().top + oy);
      cropDrag.rect = { x: Math.max(baseX, sx) - rectBounds.left, y: Math.max(baseY, sy) - rectBounds.top, w: Math.min(ex, baseX+cellW) - Math.max(sx, baseX), h: Math.min(ey, baseY+cellH) - Math.max(sy, baseY) };
      if (cropDrag.rect.w < 0) cropDrag.rect.w = 0; if (cropDrag.rect.h < 0) cropDrag.rect.h = 0;
      redraw();
    });

    window.addEventListener('mouseup', (ev)=>{
      if (!cropDrag) return;
      // convert cropDrag.rect (display pixels inside cell) -> source bbox for that cell
      const rectBounds = canvas.getBoundingClientRect();
      const { cw, ch, scaleX, scaleY } = getDisplayCellSize();
      const box = cropDrag.rect;
      if (box && box.w > 2 && box.h > 2){
        const idx = rcToIndex(cropDrag.startCell.r, cropDrag.startCell.c);
        // normalized coords inside cell (display -> source)
        const nx = box.x / cw, ny = box.y / ch, nw = box.w / cw, nh = box.h / ch;
        const sx = Math.round(nx * fw), sy = Math.round(ny * fh), sw = Math.round(nw * fw), sh = Math.round(nh * fh);
        frameBoxes[idx] = { x: Math.max(0, sx), y: Math.max(0, sy), w: Math.max(1, sw), h: Math.max(1, sh) };
      }
      cropDrag = null; redraw();
    });

    // helpers: selected list, assigned table, crops summary
    function updateSelectedList(){ const el = document.getElementById('selectedList'); el.textContent = selected.size ? Array.from(selected).slice(0,40).join(', ') + (selected.size>40?' ...':'') : '(none)'; }
    function updateCropsSummary(){
      const cropCount = Object.keys(frameBoxes).length;
      const markerCount = cellMeta ? cellMeta.filter(m => m && m.markerBBox).length : 0;
      document.getElementById('cropsSummary').textContent = `Crops: ${cropCount} · Markers detected: ${markerCount}`;
    }

    function framesToDef(indices){ if (!indices || indices.length===0) return null; const sorted = indices.slice().sort((a,b)=>a-b); const rowsSet = new Set(sorted.map(i=>Math.floor(i/cols))); if (rowsSet.size === 1){ const r = Math.floor(sorted[0]/cols); const colsOnly = sorted.map(i=>i%cols); const minC = Math.min(...colsOnly); const maxC = Math.max(...colsOnly); if (maxC - minC + 1 === colsOnly.length) return { row: r, start: minC, count: colsOnly.length }; } return sorted; }

    function setMapping(keyPath, def){ const parts = keyPath.split('.'); let cur = mappingData; for (let i=0;i<parts.length-1;i++){ const p = parts[i]; if (!cur[p]) cur[p] = {}; cur = cur[p]; } cur[parts[parts.length-1]] = def; redraw(); }
    function removeMapping(keyPath){ const parts = keyPath.split('.'); let cur = mappingData; for (let i=0;i<parts.length-1;i++){ cur = cur[parts[i]]; if (!cur) return; } delete cur[parts[parts.length-1]]; redraw(); }

    // UI wiring
    const animSelect = document.getElementById('animSelect');
    const dirSelect = document.getElementById('directionSelect');
    const assignBtn = document.getElementById('assignBtn');
    const clearSelBtn = document.getElementById('clearSel');
    const assignedTable = document.getElementById('assignedTable');
    const autoFillBtn = document.getElementById('autoFill');
    const autoFitBtn = document.getElementById('autoFitSelected');
    const autoFitAllBtn = document.getElementById('autoFitAll');
    const clearCropsBtn = document.getElementById('clearCrops');
    const cropModeToggle = document.getElementById('cropModeToggle');
    const sheetSelect = document.getElementById('sheetSelect');
    const reloadSheet = document.getElementById('reloadSheet');
    const downloadBtn = document.getElementById('downloadJson');
    const copyBtn = document.getElementById('copyJson');
    const exportBtn = document.getElementById('exportSnippet');
    const exportPreview = document.getElementById('exportPreview');

    // built-in animation names (not removable)
    const builtInAnims = new Set(['idle','walk','liftIdle','liftWalk','throw','punch','push','jumpWarp','stun','bomberCart','waiting','victory','drawGame','minecart','specialExploder','explode']);

    // custom animation persistence and helpers
    const customAnims = new Set();
    function renderAnimOption(name, isCustom){
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name + (isCustom ? ' (custom)' : '');
      if (isCustom) opt.dataset.custom = '1';
      animSelect.appendChild(opt);
    }
    function saveCustomAnims(){
      try{
        const list = Array.from(customAnims);
        const dirMap = {};
        list.forEach(n => { dirMap[n] = directionalAnims.has(n); });
        localStorage.setItem('spritesheetInspector.customAnims', JSON.stringify({ list, directional: dirMap }));
      }catch(e){}
    }
    function loadCustomAnims(){
      try{
        const raw = localStorage.getItem('spritesheetInspector.customAnims');
        if (!raw) return;
        const saved = JSON.parse(raw);
        if (!saved || !Array.isArray(saved.list)) return;
        saved.list.forEach(name => {
          if (!builtInAnims.has(name) && !customAnims.has(name)){
            customAnims.add(name);
            renderAnimOption(name, true);
            if (saved.directional && saved.directional[name]) directionalAnims.add(name);
          }
        });
      }catch(e){}
    }
    function addCustomAnim(name, isDirectional){
      name = String(name || '').trim();
      if (!/^[a-zA-Z0-9_-]+$/.test(name)){ alert('Invalid name — use letters, numbers, underscore or hyphen only'); return false; }
      if (builtInAnims.has(name) || customAnims.has(name)){ alert('Animation already exists'); return false; }
      customAnims.add(name);
      renderAnimOption(name, true);
      if (isDirectional) directionalAnims.add(name);
      saveCustomAnims();
      animSelect.value = name;
      animSelect.dispatchEvent(new Event('change'));
      updateRemoveAnimBtn();
      return true;
    }
    function removeCustomAnim(name){
      if (!customAnims.has(name)) return false;
      const opt = animSelect.querySelector(`option[value="${name}"]`);
      if (opt) opt.remove();
      customAnims.delete(name);
      directionalAnims.delete(name);
      saveCustomAnims();
      animSelect.value = 'idle';
      animSelect.dispatchEvent(new Event('change'));
      updateRemoveAnimBtn();
      return true;
    }
    function updateRemoveAnimBtn(){
      const removeAnimBtn = document.getElementById('removeAnimBtn');
      if (!removeAnimBtn) return;
      removeAnimBtn.disabled = !customAnims.has(animSelect.value);
    }

    // restore any custom animations from previous sessions
    loadCustomAnims();
    updateRemoveAnimBtn();

    // wire add/remove inputs
    const newAnimNameInput = document.getElementById('newAnimName');
    const newAnimDirectionalInput = document.getElementById('newAnimDirectional');
    const addAnimBtn = document.getElementById('addAnimBtn');
    const removeAnimBtn = document.getElementById('removeAnimBtn');
    addAnimBtn.addEventListener('click', ()=>{ if (!newAnimNameInput.value.trim()) return alert('Enter a name for the new animation'); addCustomAnim(newAnimNameInput.value.trim(), !!newAnimDirectionalInput.checked); newAnimNameInput.value = ''; newAnimDirectionalInput.checked = false; });
    removeAnimBtn.addEventListener('click', ()=>{ const sel = animSelect.value; if (!customAnims.has(sel)) return alert('Only custom animations can be removed'); if (confirm('Remove custom animation "' + sel + '"?')) removeCustomAnim(sel); });
    // also update remove button when selection changes
    animSelect.addEventListener('change', updateRemoveAnimBtn);

    const directionalAnims = new Set(['walk','idle','liftIdle','liftWalk']);
    animSelect.addEventListener('change', ()=>{ dirSelect.style.display = directionalAnims.has(animSelect.value) ? 'inline-block' : 'none'; });

    assignBtn.addEventListener('click', ()=>{
      if (selected.size === 0){ alert('Select one or more frames first (click/drag)'); return; }
      const label = animSelect.value;
      const indices = Array.from(selected).sort((a,b)=>a-b);
      const def = framesToDef(indices);
      // allow direction-subkeys for directional animations (idle, walk, liftIdle, liftWalk)
      if (directionalAnims.has(label)){
        const dir = dirSelect.value || 'down';
        setMapping(`${label}.${dir}`, def);
      } else {
        setMapping(label, def);
      }
    });
    clearSelBtn.addEventListener('click', ()=>{ selected.clear(); redraw(); });

    cropModeToggle.addEventListener('click', ()=>{ cropMode = !cropMode; cropModeToggle.style.background = cropMode ? '#ffc107' : ''; cropModeToggle.textContent = cropMode ? 'Crop mode (ON)' : 'Crop mode'; });

    autoFitBtn.addEventListener('click', ()=>{
      if (selected.size === 0) return alert('Select frames first');
      Array.from(selected).forEach(idx => {
        const meta = cellMeta[idx];
        if (meta){
          // prefer explicit marker bbox (blue-cube) when present — it's what you added to the V2 sheet
          if (meta.markerBBox) frameBoxes[idx] = meta.markerBBox;
          else if (!meta.empty) frameBoxes[idx] = meta.bbox;
          else frameBoxes[idx] = { x:0,y:0,w:fw,h:fh };
        } else {
          frameBoxes[idx] = { x:0,y:0,w:fw,h:fh };
        }
      });
      redraw();
    });
    clearCropsBtn.addEventListener('click', ()=>{ for (const k of Object.keys(frameBoxes)) delete frameBoxes[k]; redraw(); });

    // -------- selection preview / pixel-zoom helpers --------
    const cellPreview = document.getElementById('cellPreview');
    const previewCtx = cellPreview.getContext('2d');
    const previewZoomInput = document.getElementById('previewZoom');
    const previewZoomInc = document.getElementById('previewZoomInc');
    const previewZoomDec = document.getElementById('previewZoomDec');
    const previewZoomFit = document.getElementById('previewZoomFit');
    const previewFBLabel = document.getElementById('previewFB');
    const nudgeLeft = document.getElementById('nudgeLeft');
    const nudgeRight = document.getElementById('nudgeRight');
    const nudgeUp = document.getElementById('nudgeUp');
    const nudgeDown = document.getElementById('nudgeDown');
    const trimBlueBtn = document.getElementById('trimBlue');
    const applyPreviewToSelectedBtn = document.getElementById('applyPreviewToSelected');

    function getPreviewIndex(){ return selected.size ? Array.from(selected)[0] : null; }
    function ensureFrameBox(idx){ if (!frameBoxes[idx]) frameBoxes[idx] = { x:0, y:0, w:fw, h:fh }; }

    function updateCellPreview(){
      const idx = getPreviewIndex();
      if (!sheetCanvas) { previewCtx.clearRect(0,0,cellPreview.width, cellPreview.height); previewFBLabel.textContent='(none)'; return; }
      previewCtx.imageSmoothingEnabled = false;
      previewCtx.clearRect(0,0,cellPreview.width, cellPreview.height);
      if (idx == null) { previewFBLabel.textContent = '(none)'; return; }
      const {r,c} = indexToRC(idx);
      const fb = frameBoxes[idx] || { x:0, y:0, w:fw, h:fh };
      const sx = gridOffsetX + c*fw + fb.x;
      const sy = gridOffsetY + r*fh + fb.y;
      const sw = Math.max(1, fb.w);
      const sh = Math.max(1, fb.h);
      let zoom = Math.max(1, parseInt(previewZoomInput.value, 10) || 4);
      const maxFit = Math.floor(Math.min(cellPreview.width / sw, cellPreview.height / sh));
      const fitZoom = Math.max(1, Math.min(zoom, maxFit));
      const drawW = Math.min(cellPreview.width, sw * fitZoom);
      const drawH = Math.min(cellPreview.height, sh * fitZoom);
      const dx = Math.floor((cellPreview.width - drawW) / 2);
      const dy = Math.floor((cellPreview.height - drawH) / 2);
      try{ previewCtx.drawImage(sheetCanvas, sx, sy, sw, sh, dx, dy, drawW, drawH); } catch(e){ console.warn('preview draw failed', e); }
      previewCtx.strokeStyle = 'rgba(0,0,0,0.6)'; previewCtx.lineWidth = 1; previewCtx.strokeRect(dx - 0.5, dy - 0.5, drawW + 1, drawH + 1);
      previewCtx.setLineDash([3,3]); previewCtx.strokeStyle = 'rgba(0,200,100,0.9)'; previewCtx.strokeRect(dx+0.5, dy+0.5, drawW-1, drawH-1); previewCtx.setLineDash([]);
      previewFBLabel.textContent = `${fb.x}, ${fb.y}, ${fb.w}, ${fb.h}`;
    }

    previewZoomInc.addEventListener('click', ()=>{ previewZoomInput.value = Math.max(1, (parseInt(previewZoomInput.value,10)||4) + 1); updateCellPreview(); });
    previewZoomDec.addEventListener('click', ()=>{ previewZoomInput.value = Math.max(1, (parseInt(previewZoomInput.value,10)||4) - 1); updateCellPreview(); });
    previewZoomInput.addEventListener('input', updateCellPreview);
    previewZoomFit.addEventListener('click', ()=>{ previewZoomInput.value = Math.max(1, Math.floor(Math.min(cellPreview.width / fw, cellPreview.height / fh))); updateCellPreview(); });

    function nudgeFrameBox(dx, dy){ const idx = getPreviewIndex(); if (idx == null) return; ensureFrameBox(idx); const fb = frameBoxes[idx]; fb.x = Math.max(0, Math.min(fw - 1, fb.x + dx)); fb.y = Math.max(0, Math.min(fh - 1, fb.y + dy)); redraw(); updateCellPreview(); }
    nudgeLeft.addEventListener('click', ()=> nudgeFrameBox(-1,0));
    nudgeRight.addEventListener('click', ()=> nudgeFrameBox(1,0));
    nudgeUp.addEventListener('click', ()=> nudgeFrameBox(0,-1));
    nudgeDown.addEventListener('click', ()=> nudgeFrameBox(0,1));

    trimBlueBtn.addEventListener('click', ()=>{
      const idx = getPreviewIndex(); if (idx == null) return; ensureFrameBox(idx); const fb = frameBoxes[idx];
      const sx = gridOffsetX + (indexToRC(idx).c)*fw + fb.x;
      const sy = gridOffsetY + (indexToRC(idx).r)*fh + fb.y;
      try{
        const data = sheetCtx.getImageData(sx, sy, fb.w, fb.h).data;
        const isBluePixel = (r,g,b,a) => (a>32 && b>120 && (b - Math.max(r,g) > 40));
        let leftTrim = 0; outer: for (; leftTrim < fb.w; leftTrim++){ for (let yy=0; yy<fb.h; yy++){ const i = (yy*fb.w + leftTrim)*4; if (!isBluePixel(data[i],data[i+1],data[i+2],data[i+3])) break outer; } }
        let rightTrim = 0; outer2: for (; rightTrim < fb.w; rightTrim++){ const cx = fb.w - 1 - rightTrim; for (let yy=0; yy<fb.h; yy++){ const i = (yy*fb.w + cx)*4; if (!isBluePixel(data[i],data[i+1],data[i+2],data[i+3])) break outer2; } }
        let topTrim = 0; outer3: for (; topTrim < fb.h; topTrim++){ for (let xx=0; xx<fb.w; xx++){ const i = (topTrim*fb.w + xx)*4; if (!isBluePixel(data[i],data[i+1],data[i+2],data[i+3])) break outer3; } }
        let bottomTrim = 0; outer4: for (; bottomTrim < fb.h; bottomTrim++){ const cy = fb.h - 1 - bottomTrim; for (let xx=0; xx<fb.w; xx++){ const i = (cy*fb.w + xx)*4; if (!isBluePixel(data[i],data[i+1],data[i+2],data[i+3])) break outer4; } }
        const newX = Math.min(fb.x + leftTrim, fw-1);
        const newY = Math.min(fb.y + topTrim, fh-1);
        const newW = Math.max(1, fb.w - leftTrim - rightTrim);
        const newH = Math.max(1, fb.h - topTrim - bottomTrim);
        fb.x = newX; fb.y = newY; fb.w = newW; fb.h = newH;
        redraw(); updateCellPreview();
      } catch(e){ console.warn('trimBlue failed', e); alert('Trim failed — ensure sheet is loaded and selection has frameBox'); }
    });

    applyPreviewToSelectedBtn.addEventListener('click', ()=>{
      const idx = getPreviewIndex(); if (idx == null) return alert('Select a frame first');
      if (!frameBoxes[idx]) return alert('No frameBox to apply (draw or auto-fit first)');
      const src = frameBoxes[idx];
      Array.from(selected).forEach(i => { frameBoxes[i] = { x: src.x, y: src.y, w: src.w, h: src.h }; });
      redraw();
    });

    // uniform-trim helpers
    const uniformTrimInput = document.getElementById('uniformTrimInput');
    const trimUniformSelected = document.getElementById('trimUniformSelected');
    const trimUniformAll = document.getElementById('trimUniformAll');
    const resetUniformTrim = document.getElementById('resetUniformTrim');

    function applyUniformTrim(n, targets /* 'selected' | 'all' */){
      const trim = Math.max(0, Math.floor(n) || 0);
      const indices = (targets === 'all') ? Array.from({length: cols*rows}, (_,i)=>i) : Array.from(selected);
      indices.forEach(idx => {
        if (idx == null) return;
        if (!frameBoxes[idx]) frameBoxes[idx] = { x: 0, y: 0, w: fw, h: fh };
        const fb = frameBoxes[idx];
        // compute new values
        const nx = Math.min(fb.x + trim, fw-1);
        const ny = Math.min(fb.y + trim, fh-1);
        const nw = Math.max(1, Math.max(0, fb.w - 2*trim));
        const nh = Math.max(1, Math.max(0, fb.h - 2*trim));
        // clamp so crop stays inside cell
        fb.x = Math.min(Math.max(0, nx), fw - nw);
        fb.y = Math.min(Math.max(0, ny), fh - nh);
        fb.w = Math.min(nw, fw - fb.x);
        fb.h = Math.min(nh, fh - fb.y);
      });
      redraw();
    }

    trimUniformSelected.addEventListener('click', ()=> applyUniformTrim(parseInt(uniformTrimInput.value,10)||0, 'selected'));
    trimUniformAll.addEventListener('click', ()=> { if (!confirm('Trim every cell by this many pixels on all sides?')) return; applyUniformTrim(parseInt(uniformTrimInput.value,10)||0, 'all'); });
    resetUniformTrim.addEventListener('click', ()=>{ uniformTrimInput.value = 0; });

    // hook preview update into redraw
    const _oldRedraw = redraw;
    function redraw(){ _oldRedraw(); updateCellPreview(); }


    function renderAssignedTable(){ const rows = []; function pushRow(k, def){ const repr = (Array.isArray(def) ? '['+def.join(',')+']' : `{ row: ${def.row}, start: ${def.start}, count: ${def.count} }`); rows.push({k, repr}); }
      Object.entries(mappingData).forEach(([k,v]) => {
        // if the mapping is a direction-keyed object (e.g. idle.down, walk.left), expand each sub-entry
        if (typeof v === 'object' && !(v && v.row != null && v.start != null && v.count != null)){
          Object.entries(v).forEach(([subk, def]) => pushRow(`${k}.${subk}`, def));
        } else {
          pushRow(k, v);
        }
      });
      if (rows.length === 0){ assignedTable.innerHTML = '<tr><td colspan="3">(no mappings)</td></tr>'; return; }
      assignedTable.innerHTML = rows.map(r => `
        <tr>
          <td>${r.k}</td>
          <td><code>${r.repr}</code></td>
          <td><button data-key="${r.k}" class="small remove-mapping">Remove</button> <button data-key="${r.k}" class="small show-mapping">Highlight</button></td>
        </tr>
      `).join('');
      assignedTable.querySelectorAll('.remove-mapping').forEach(b=> b.addEventListener('click', ev=> { removeMapping(ev.target.dataset.key); }));
      assignedTable.querySelectorAll('.show-mapping').forEach(b=> b.addEventListener('click', ev=> { highlightMapping(ev.target.dataset.key); })); }

    function highlightMapping(keyPath){
      drawIndices();
      const parts = keyPath.split('.');
      let def = mappingData[parts[0]]; if (!def) return; if (parts.length>1) def = def[parts[1]]; if (!def) return;
      const { cw, ch } = getDisplayCellSize();
      const { ox, oy } = getDisplayGridOffset();
      function drawForDef(d){
        if (Array.isArray(d)){
          d.forEach(idx=>{ const {r,c} = indexToRC(idx); const base = displayCellRect(r,c); ctx.strokeStyle='rgba(255,140,0,0.95)'; ctx.lineWidth=3; ctx.strokeRect(base.x+2, base.y+2, base.w-4, base.h-4); });
        } else if (d && d.row!=null){
          for (let i=0;i<d.count;i++){ const c = d.start+i; const base = displayCellRect(d.row, c); ctx.strokeStyle='rgba(255,140,0,0.95)'; ctx.lineWidth=3; ctx.strokeRect(base.x+2, base.y+2, base.w-4, base.h-4); }
        }
      }
      drawForDef(def);
    }

    function formatExportJSON(){ return JSON.stringify({ animations: mappingData, frameBoxes: frameBoxes }, null, 2); }
    function updateExportPreview(){ exportPreview.textContent = formatExportJSON(); }

    // download/copy include frameBoxes now
    downloadBtn.addEventListener('click', ()=>{ const payload = { animations: mappingData, frameBoxes: frameBoxes }; const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'bomberman_animations_with_crops.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });
    copyBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(formatExportJSON()); alert('JSON copied to clipboard'); } catch(e){ alert('Clipboard copy failed — use Download JSON'); } });
    exportBtn.addEventListener('click', ()=>{ updateExportPreview(); window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }); });

    // --- Import JSON (file + paste) ---
    const importJsonBtn = document.getElementById('importJsonBtn');
    const importJsonFile = document.getElementById('importJsonFile');
    const pasteJsonBtn = document.getElementById('pasteJsonBtn');

    function clearObject(obj){ Object.keys(obj).forEach(k => delete obj[k]); }

    function applyImportedJSON(data){
      if (!data || typeof data !== 'object') return alert('Invalid JSON');
      // apply animations
      if (data.animations){
        clearObject(mappingData);
        Object.entries(data.animations).forEach(([k,v]) => { mappingData[k] = v; });
      }
      // apply frameBoxes
      if (data.frameBoxes){
        clearObject(frameBoxes);
        Object.entries(data.frameBoxes).forEach(([k,v]) => { frameBoxes[k] = v; });
      }
      renderAssignedTable(); redraw();
      alert('Imported JSON into inspector');
    }

    importJsonBtn.addEventListener('click', ()=> importJsonFile.click());
    importJsonFile.addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        try{ const parsed = JSON.parse(reader.result); applyImportedJSON(parsed); } catch(e){ alert('Invalid JSON file: ' + e.message); }
      };
      reader.readAsText(f);
      // reset so same file can be re-selected
      importJsonFile.value = '';
    });

    pasteJsonBtn.addEventListener('click', async ()=>{
      const txt = prompt('Paste JSON here');
      if (!txt) return;
      try{ const parsed = JSON.parse(txt); applyImportedJSON(parsed); } catch(e){ alert('Invalid JSON: ' + e.message); }
    });

    // Auto-fill walk -> idle helper
    autoFillBtn.addEventListener('click', ()=>{
      if (!mappingData.walk) return alert('No walk mapping to auto-fill from');
      if (!mappingData.idle) mappingData.idle = {};
      Object.entries(mappingData.walk).forEach(([dir, def]) => {
        if (Array.isArray(def)) mappingData.idle[dir] = [def[0]];
        else if (def && def.row != null) mappingData.idle[dir] = { row: def.row, start: def.start, count: 1 };
      });
      renderAssignedTable(); redraw();
      alert('Idle frames auto-filled from walk mappings');
    });

    // sheet selection
    sheetSelect.addEventListener('change', ()=>{ img.src = `../assets/${sheetSelect.value}`; });
    reloadSheet.addEventListener('click', ()=>{ img.src = `../assets/${sheetSelect.value}`; });

    // compute cellMeta when sheet image finishes loading
function initCanvas(){
      // compute dynamic cols/rows from the natural image size
      cols = Math.floor(img.naturalWidth / fw) || 28;
      rows = Math.floor(img.naturalHeight / fh) || 5;

      // make canvas match displayed image size *and* handle high-DPI/zoom correctly
      const dpr = window.devicePixelRatio || 1;
      const displayW = img.clientWidth;
      const displayH = img.clientHeight;
      canvas.style.width = displayW + 'px';
      canvas.style.height = displayH + 'px';
      canvas.width = Math.round(displayW * dpr);
      canvas.height = Math.round(displayH * dpr);
      // keep drawing coordinates in CSS pixels by scaling context
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // try to restore manual grid (if the user previously applied one)
      try{
        const saved = JSON.parse(localStorage.getItem('spritesheetInspector.grid'));
        if (saved && typeof saved.fw === 'number'){
          // apply saved values and lock grid so detection doesn't override
          fw = saved.fw || fw; fh = saved.fh || fh;
          gridOffsetX = saved.gridOffsetX || gridOffsetX;
          gridOffsetY = saved.gridOffsetY || gridOffsetY;
          gridLocked = true;
          cols = Math.floor((img.naturalWidth - gridOffsetX) / fw);
          rows = Math.floor((img.naturalHeight - gridOffsetY) / fh);
        }
      } catch(e) { /* ignore */ }

      // update UI grid info
      document.getElementById('colsCount').textContent = cols;
      document.getElementById('rowsCount').textContent = rows;
      document.getElementById('framesCount').textContent = (cols * rows);
      try{ computeCellMeta(); } catch(e){ console.warn('computeCellMeta failed', e); }
      redraw();
    }

    img.addEventListener('load', initCanvas);
    window.addEventListener('resize', () => { if (img.complete) initCanvas(); });
    if (img.complete) initCanvas();

    // --- manual grid controls wiring ---
    const cellWInput = document.getElementById('cellW');
    const cellHInput = document.getElementById('cellH');
    const gridOffXInput = document.getElementById('gridOffsetX');
    const gridOffYInput = document.getElementById('gridOffsetY');
    const applyGridBtn = document.getElementById('applyGrid');
    const resetGridBtn = document.getElementById('resetGrid');

    function updateGridControls(){
      cellWInput.value = fw;
      cellHInput.value = fh;
      gridOffXInput.value = gridOffsetX || 0;
      gridOffYInput.value = gridOffsetY || 0;
      // update manual cols/rows inputs
      const colsInputEl = document.getElementById('colsInput');
      const rowsInputEl = document.getElementById('rowsInput');
      if (colsInputEl) colsInputEl.value = cols;
      if (rowsInputEl) rowsInputEl.value = rows;
      document.getElementById('colsCount').textContent = cols;
      document.getElementById('rowsCount').textContent = rows;
      document.getElementById('framesCount').textContent = cols * rows;
    }

    applyGridBtn.addEventListener('click', ()=>{
      const nw = Math.max(1, parseInt(cellWInput.value, 10) || fw);
      const nh = Math.max(1, parseInt(cellHInput.value, 10) || fh);
      const ox = parseInt(gridOffXInput.value, 10) || 0;
      const oy = parseInt(gridOffYInput.value, 10) || 0;
      const userCols = Math.max(1, parseInt(document.getElementById('colsInput').value, 10) || cols);
      const userRows = Math.max(1, parseInt(document.getElementById('rowsInput').value, 10) || rows);

      // remember previous cell size so we can scale existing crops
      const prevFw = fw, prevFh = fh;

      fw = nw; fh = nh;
      // apply manual offset and lock grid so auto-detection won't override
      gridOffsetX = Math.max(0, Math.min(ox, img.naturalWidth - fw));
      gridOffsetY = Math.max(0, Math.min(oy, img.naturalHeight - fh));
      gridLocked = true;

      // use explicit cols/rows if provided (clamped so they fit the image)
      cols = Math.min(userCols, Math.floor((img.naturalWidth - gridOffsetX) / fw));
      rows = Math.min(userRows, Math.floor((img.naturalHeight - gridOffsetY) / fh));

      // recompute cell metadata using new fw/fh
      try{ computeCellMeta(); } catch(e){ console.warn(e); }

      // scale any existing user frameBoxes so they keep the same relative rect inside the cell
      const sx = fw / prevFw; const sy = fh / prevFh;
      Object.keys(frameBoxes).forEach(k => {
        const v = frameBoxes[k];
        frameBoxes[k] = {
          x: Math.round(v.x * sx),
          y: Math.round(v.y * sy),
          w: Math.max(1, Math.round(v.w * sx)),
          h: Math.max(1, Math.round(v.h * sy))
        };
      });

      // persist manual grid so it survives reloads (include cols/rows)
      try{ localStorage.setItem('spritesheetInspector.grid', JSON.stringify({ fw, fh, gridOffsetX, gridOffsetY, cols, rows })); }catch(e){}
      updateGridControls(); redraw();
    });

    resetGridBtn.addEventListener('click', ()=>{
      // unlock and restore detected offsets
      gridLocked = false;
      gridOffsetX = detectedGridOffsetX || 0; gridOffsetY = detectedGridOffsetY || 0;
      cols = Math.floor((img.naturalWidth - gridOffsetX) / fw);
      rows = Math.floor((img.naturalHeight - gridOffsetY) / fh);
      try{ computeCellMeta(); } catch(e){ console.warn(e); }
      // remove persisted manual grid
      try{ localStorage.removeItem('spritesheetInspector.grid'); } catch(e){}
      updateGridControls(); redraw();
    });

    // live update when user edits cols/rows (auto-apply)
    const colsInputEl = document.getElementById('colsInput');
    const rowsInputEl = document.getElementById('rowsInput');
    function handleColsInput(){
      let v = Math.max(1, parseInt(colsInputEl.value,10) || 1);
      const maxCols = Math.max(1, Math.floor((img.naturalWidth - gridOffsetX) / fw));
      v = Math.min(v, maxCols);
      cols = v;
      colsInputEl.value = cols;
      gridLocked = true;
      try{ computeCellMeta(); } catch(e){ console.warn(e); }
      updateGridControls(); redraw();
    }
    colsInputEl.addEventListener('input', handleColsInput);
    colsInputEl.addEventListener('change', handleColsInput);
    function handleRowsInput(){
      let v = Math.max(1, parseInt(rowsInputEl.value,10) || 1);
      const maxRows = Math.max(1, Math.floor((img.naturalHeight - gridOffsetY) / fh));
      v = Math.min(v, maxRows);
      rows = v;
      rowsInputEl.value = rows;
      gridLocked = true;
      try{ computeCellMeta(); } catch(e){ console.warn(e); }
      updateGridControls(); redraw();
    }
    rowsInputEl.addEventListener('input', handleRowsInput);
    rowsInputEl.addEventListener('change', handleRowsInput);

    // update controls after initial detection
    setTimeout(updateGridControls, 50);

  </script>
</body>
</html>